% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dupeset_conflicts.R
\name{dupeset_conflicts}
\alias{dupeset_conflicts}
\alias{count_conflicts}
\alias{isolate_conflicts}
\alias{flatten_conflicts}
\title{Handle conflicting values within dupe sets}
\usage{
count_conflicts(df, dupe_id = "dupe_id", ignore_empty = TRUE, silent = FALSE)

isolate_conflicts(
  df,
  var,
  dupe_id = "dupe_id",
  ignore_empty = TRUE,
  silent = FALSE
)

flatten_conflicts(
  df,
  var = colnames(df),
  dupe_id = "dupe_id",
  sep = " | ",
  silent = FALSE
)
}
\arguments{
\item{df}{A dataframe containing dupe sets and the duplicate ID variable returned by \code{\link[=undupe]{undupe()}}.}

\item{dupe_id}{The duplicate ID variable name. Defaults to \code{"dupe_id"}.}

\item{ignore_empty}{Logical: omit blank strings and \code{NA}s when finding conflicts if \code{TRUE}.}

\item{silent}{Logical: silence progress indicator if \code{TRUE}.}

\item{var}{Variable names in \code{df}. SAY WHAT HAPPENS SPECIFICALLY IN ISOLATE AND FLATTEN....}

\item{sep}{A string to separate the merged values from a dupe set. Defaults to \code{" | "}.}
}
\value{
\subsection{Count conflicts}{

A dataframe with one row per variable in \code{df} (omitting \code{dupe_id} and \code{dupe_order}). The returned dataframe has three columns:
\itemize{
\item \code{variable}: The variable name from \code{df}.
\item \code{n}: The count of dupe sets in \code{df} with conflicting values.
\item \code{pct}: The percentage of dupe sets in \code{df} with conflicting values.
}
}

\subsection{Isolate conflicts}{

A subset of \code{df} containing only dupe sets with conflicts in the variables provided in \code{var}.
}

\subsection{Flatten conflicts}{

A deduplicated dataframe containing one row per dupe set in \code{df} and one column per variable in \code{var} plus \code{dupe_id}.
}
}
\description{
These functions take the output of \code{\link[=undupe]{undupe()}} (\code{df_dupesets} and/or \code{df_full}) as the first argument.
}
\details{
\subsection{Count conflicts}{

\code{count_conflicts()} counts the occurrence of conflicting values within dupe sets for each variable in the dataframe. When a dupe set contains any conflicts within the values of a single variable (i.e., all values belonging to the members of that dupe set are not identical), the conflict count for that variable increases by one. The sum of all such conflicts across all dupe sets for each variable is returned, as well as the percentage of dupe sets containing conflicts for each variable.
}

\subsection{Isolate conflicts}{

\code{isolate_conflicts()} returns a dataframe containing only those dupe sets that have conflicting values in the variables named in \code{var}. This makes it easier to visually inspect the data and look for patterns among dupe sets.
}

\subsection{Flatten conflicts}{

\code{flatten_conflicts()} deduplicates a dataframe containing dupe sets (either \code{df_full} or \code{df_dupesets}). Within each dupe set, conflicting values are merged into one cell per dupe set for selected variables so that no data is lost as a result of deduplication. Only unique values are kept, omitting \code{NA}s and empty strings.
}
}
\examples{
n_rows <- 20

df <- data.frame(
  x = sample(c("cat", "horse", "howler monkey"), size = n_rows, replace = TRUE),
  y = sample(c(1, 10, 100, NA), size = n_rows, replace = TRUE),
  z = sample(c("banana", "carrot", "pickle"), size = n_rows, replace = TRUE)
)

undp <- undupe(df, var = c("x", "y"))

df_count <- count_conflicts(undp$df_dupesets)

df_isolated <- isolate_conflicts(undp$df_dupesets, var = "z")

df_flat <- flatten_conflicts(undp$df_dupesets, var = "z")

}
\seealso{
Other undupe functions: 
\code{\link{undupe}()}
}
\concept{undupe functions}
