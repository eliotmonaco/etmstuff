% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatten_conflicts.R
\name{flatten_conflicts}
\alias{flatten_conflicts}
\title{Flatten conflicting values for each variable in a dupeset}
\usage{
flatten_conflicts(df, var, dupe_id, sep = " | ", silent = FALSE)
}
\arguments{
\item{df}{A dataframe of dupesets (or the full data set) returned by \code{\link[=undupe]{undupe()}}.}

\item{var}{A character vector of variable names in \code{df}.}

\item{dupe_id}{The duplicate ID variable name, which groups all members of a duplicate set.}

\item{sep}{A string to use as a separator between the aggregated values from a duplicate set. The default is " | ".}

\item{silent}{Logical: silence output to console if \code{TRUE}.}
}
\value{
A dataframe of flattened values, with one row per dupeset in \code{df} and one column per variable in \code{var}.
}
\description{
\code{flatten_conflicts()} combines the different values for selected variables (named in \code{var}) into one cell so that no data is lost as a result of deduplication. \code{flatten_conflicts()} must be run on either \code{df_full} or \code{df_dupesets}, both produced by \code{\link[=undupe]{undupe()}}.

Each dupeset is essentially flattened into one row, with each variable named in \code{var} combining all of the formerly separate values from each duplicate into a single string. Only unique values are kept, separated by the character(s) in \code{sep}. \code{NA}s and blank/empty strings are omitted.
}
\section{Deduplication}{

Deduplication is the process of reducing a dataframe to distinct rows only. Rows that have identical values across a set of selected variables are considered duplicates. These selected variables are "visible" to the process of deduplication. All other variables in the dataframe are "invisible" to deduplication, so they are ignored. Within dupesets, variables that were invisible to deduplication can have conflicting values.

The \code{\link[=undupe]{undupe()}} function produces both a deduplicated dataframe and a dataframe of all duplicate rows (dupesets) pulled from the original dataframe.

For a more detailed explanation of deduplication, see the \code{\link[=undupe]{undupe()}} documentation.
}

\examples{
n_rows <- 20
df <- data.frame(
  x = sample(c("cat", "horse", "howler monkey"), size = n_rows, replace = TRUE),
  y = sample(c(1, 10, 100, NA), size = n_rows, replace = TRUE),
  z = sample(c("banana", "carrot", "pickle"), size = n_rows, replace = TRUE)
)
undupe <- undupe(df, visible_vars = c("x", "y"))
df_flattened <- flatten_conflicts(undupe[["df_dupesets"]], var = "z", dupe_id = "dupe_id")

}
\seealso{
Other undupe functions: 
\code{\link{count_conflicts}()},
\code{\link{dupes2xl}()},
\code{\link{isolate_conflicts}()},
\code{\link{undupe}()}
}
\concept{undupe functions}
