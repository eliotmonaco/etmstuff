% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/undupe.R
\name{undupe}
\alias{undupe}
\title{Deduplicate a dataframe}
\usage{
undupe(df, var, prefix = "dupe")
}
\arguments{
\item{df}{A dataframe.}

\item{var}{A vector of variables in \code{df} whose values must match for rows to be considered duplicates. All other variables will be retained in the output but ignored during deduplication.}

\item{prefix}{A prefix for the new duplicate ID and duplicate order variable names. Defaults to \code{"dupe"}, creating \code{dupe_id} and \code{dupe_order}.}
}
\value{
A list containing three dataframes:
\itemize{
\item \code{distinct}: the deduplicated dataframe.
\item \code{dupesets}: a dataframe of grouped duplicate sets.
\item \code{full}: the original dataframe, \code{df}, with the duplicate ID and duplicate order variables added.
}
}
\description{
This function identifies duplicate rows in a dataframe based on a subset of variables provided in the arguments. Duplicates are rows that have identical values across this set of variables.
}
\details{
\code{undupe()} adds a duplicate identifier (\code{dupe_id}) to each row, which is a hash determined by the sequence of values in \code{var}. It also adds an integer (\code{dupe_order}) which indicates the original row order of each member in a dupe set.

\code{undupe()} returns a list containing a deduplicated dataframe (equivalent to using \code{\link[dplyr:distinct]{dplyr::distinct()}}), a dataframe consisting only of dupe sets grouped together, and a copy of the original dataframe with the duplicate identifier and duplicate order variables added.
}
\examples{
n_rows <- 20

df <- data.frame(
  x = sample(c("cat", "horse", "howler monkey"), size = n_rows, replace = TRUE),
  y = sample(c(1, 10, 100, NA), size = n_rows, replace = TRUE),
  z = sample(c("banana", "carrot", "pickle"), size = n_rows, replace = TRUE)
)

undp <- undupe(df, var = c("x", "y"))

}
\seealso{
Other undupe functions: 
\code{\link{dupeset_conflicts}}
}
\concept{undupe functions}
